---
format:
  revealjs:
    height: 900
    width: 1600
    logo: "images/osu.png"
    slide-number: true
    scrollable: true
---

## Copula-Based Mixture Transition Distribution Models for Forecasting Skewed and Zero-Inflated Time Series: Methodology and Comparisons with Deep Learning LSTM Networks  

<br>

<br>

<br>

::::: columns

::: column

### Frances Lin

üõ° Dissertation Defense  

ü¶´ Oregon State University  

November 5, 2025

::: 

::: column

###

Co-Advisors: Dr. Lisa Madsen, Dr. Charlotte Wickham

Committee Members: Dr. James Molyneux, Dr. Claudio Fuentes, Dr. Prasad Tadepalli

::: 

::::: 

## Motivation  

Modeling complex patterns in sequence data is a central task across domains such as energy, insurance, and transportation. 

- ‚ö†Ô∏è Real-world time series often show skewness and zero inflation, which can undermine performance if not properly addressed. 

. . .    

Recent AI advances, such as Recurrent Neural Networks (RNNs) and Long Short-Term Memory (LSTM) networks, effectively capture nonlinear and long-range dependence. 

. . .    

- ‚ö†Ô∏è Claims of LSTM superiority can be misleading when compared to inappropriate benchmarks. 

- ‚ö†Ô∏è A prior work found comparable performance between probabilistic Mixture Transition Distribution (MTD) model and deep learning LSTM for predicting disease spread. 

--- 

![](images/nasa-1.jpg){.absolute top=0 left=0 width="900" height="675"}

![](images/nasa-2.jpg){.absolute top=0 left=950 width="250" height="675"}

![](images/nasa-3.jpg){.absolute top=0 left=1250 width="250" height="675"}

<div style="margin-top: 725px;">
¬©Ô∏è NASA GES DISC
üìç Limon Wind Energy Center, Colorado  
</div>

## NASA MERRA-2 Data

::: {.panel-tabset}

```{r}
#| echo: false
library(tidyverse)
library(gridExtra)
```

```{r}
plot_variable_by_year <- function(data, variable, m, plot) {
  p_ts <- data %>%
    ggplot(aes(x = Date, y = .data[[variable]])) + 
    geom_line() + 
    theme_minimal(base_size = 16) +
    labs(x = "time", y = paste0("windspeedat",m,"mms")) + 
    #ylim(0, 22) +  # Adjust ylim a bit
    theme(
      axis.title.x = element_text(size = 18), 
      axis.title.y = element_text(size = 18), 
      axis.text.x = element_text(size = 18), 
      axis.text.y = element_text(size = 18), 
      plot.caption = element_text(size = 18, hjust = 0) 
    ) 
  return(p_ts)
}
```

```{r}
data_dir <- "/Users/franceslin/Documents/Summer2024/data-example/merra2_wind_code_scripts_v2"
data <- readRDS(file.path(data_dir, "MWH.rds"))
data$Date <- data$MD %>% as_datetime()
data$Year <- year(data$Date)
```

### windspeeds at 50m above ground

```{r}
plot_variable_by_year(data, "WHuv50", "50")
```

### windspeeds at 10m above ground

```{r}
plot_variable_by_year(data, "WHuv10", "10")
```

### windspeeds at 2m above ground

```{r}
plot_variable_by_year(data, "WHuv2", "2")
```

::: 

## Objectives 

Part I and II

> Develop the copula-based Gamma Mixture Transition Distribution (Gamma MTD) model and its zero-inflated extension (ZIGamma MTD) to capture nonlinear dependence, skewed behavior, and semicontinuous patterns.

. . .

Part III

> Evaluate the proposed models alongside deep learning approaches, specifically the Long Short-Term Memory (LSTM) networks, demonstrating superior predictive performance and robustness.

## Roadmap 

Part I Models for Forecasting Skewed Time Series 

- Recap of MTD Models 

- Sensitivity Analysis 

- Coverage Assessment 

Part II Models for Forecasting Zero-Inflated Skewed Time Series 

- Introduction 

- Background 

- Proposed Method 

- Simulation Studies 

- Prediction 


## Roadmap 

Part III Copula-Based Probabilistic MTD Models vs. Deep Learning LSTM Networks

- Introduction 

- Background 

- Hyperparameter Tuning, Training, and Metrics 

- Simulation Studies 

- Data Application 

# Part I Models for Forecasting Skewed Time Series {background-color="#D73F09" color="white"} 

## Introduction 

Time series model captures how past values contribute to current value and uses this information to predict future value.

. . .

The mixture transition distribution (MTD) models 

- Extend the autoregressive (AR) models to accommodate discrete, continuous, and mixed time series. 

- Model each conditional distribution as a mixture of transition kernels, with random, stochastic weights. 

## Introduction and Objectives 

Our work builds upon the architecture of the MTD model introduced by Zheng et al. (2022). 

- Includes various applications, such as Gaussian, Poisson, negative binomial, and Lomax regression MTD models, extending beyond linear, Gaussian dynamics. 

. . .

However, for certain invariant marginal distributions, the transition kernel may either require careful construction or can result in a form that is not explicitly defined or too complex. 

. . .

> **Objectives:** Propose to incorporate copulas into the transition kernels to address this limitation, thereby enhancing modeling capabilities and flexibility.

. . .

> Develop the Gamma MTD model, but the framework is generalizable.

## Background 

The MTD model is a state space model. 

. . .

The MTD model was initially developed in 1985 to model high-order Markov chains, 
  
- Followed by several variant models over the years to capture non-Gaussian and nonlinear features, such as flat stretches, bursts, outliers, and change points.
  
- See Berchtold and Raftery (2022) for a complete review. 

. . .


The MTD model has primarily been used for modeling time series. 
  
- Its generalizations has also demonstrated success in modeling spatial data. 


## Model Framework: DAG; also known as Bayesian Network

Let $\{ X_t: t \in \mathbb{N} \}$ be a time series. Construct the model on a DAG, the joint distribution of $X_1$ to $X_t$ can be factorized into a product of conditional distributions as
```{=latex}
\begin{equation}
f(\textbf{x}) = f(x_1) \prod_{t=2}^t f(x_t | \textbf{x}^{t-1}). \tag{1}
\label{eq:joint_distribution}
\end{equation}
```
\scriptsize $f(x_t | \textbf{x}^{t-1})$ is the conditional probability density function (pdf) of current value $X_t$ given all of its past values $\textbf{X}^{t-1} = \textbf{x}^{t-1}$, where $\textbf{X}^{t-1} = \{X_i: i \leq t - 1 \}$ and $\textbf{x}^{t-1} = \{x_i: i \leq t - 1 \}$.

. . .

As $t$ increases, the size of the conditioning set of $X_t$ can be large. 

- Solution: Use a structured mixture model that restricts each value in the MTD model to depend only on the $L$ (a given number) lagged values.

. . .

Each conditional in (1) is modeled as a mixture of transition kernels, with weight assigned to each of the $L$ lagged values.


## MTD Order (Look-Back Steps) $L = 5$

```{dot}
graph {
  rankdir=LR; // left-to-right layout
  node [shape=circle, style=solid, fontsize=12];

  // Define nodes
  X1 [label="X‚ÇÅ"];
  X2 [label="X‚ÇÇ"];
  X3 [label="X‚ÇÉ"];
  X4 [label="X‚ÇÑ"];
  X5 [label="X‚ÇÖ"];
  X6 [label="X‚ÇÜ"];

  // Chain up to X5
  X1 -- X2 -- X3 -- X4 -- X5;

  { rank=same; X5; X6; }
}
```

## MTD Order (Look-Back Steps) $L = 5$

```{dot}
graph {
  rankdir=LR; // left-to-right layout
  node [shape=circle, style=solid, fontsize=12];

  // Define nodes
  X1 [label="X‚ÇÇ"];
  X2 [label="X‚ÇÉ"];
  X3 [label="X‚ÇÑ"];
  X4 [label="X‚ÇÖ"];
  X5 [label="X‚ÇÜ"];
  X6 [label="X‚Çá"];

  // Chain up to X5
  X1 -- X2 -- X3 -- X4 -- X5;

  { rank=same; X5; X6; }
}
```

## MTD Order (Look-Back Steps) $L = 5$

```{dot}
graph {
  rankdir=LR; // left-to-right layout
  node [shape=circle, style=solid, fontsize=10, fixedsize=true, width=0.6, fontname="Times-Roman"];

  // Define nodes
  X1 [label=< <b>X</b><sub><b>t-5</b></sub> >];
  X2 [label=< <b>X</b><sub><b>t-4</b></sub> >];
  X3 [label=< <b>X</b><sub><b>t-3</b></sub> >];
  X4 [label=< <b>X</b><sub><b>t-2</b></sub> >];
  X5 [label=< <b>X</b><sub><b>t-1</b></sub> >];
  X6 [label=< <b>X</b><sub><b>t</b></sub> >];

  // Chain up to X5
  X1 -- X2 -- X3 -- X4 -- X5;

  { rank=same; X5; X6; }
}
```


## Model Framework: Transition Kernels and Mixture Weights 

For $t > L$, the MTD model specifies the conditional distribution of $X_t$ given $\textbf{X}^{t-1} = \textbf{x}^{t-1}$ as 
```{=latex}
\begin{equation}
f(x_t | \textbf{x}^{t-1}) = \sum_{l=1}^L w_l f_l (x_t | x_{t-l}). \tag{2}
\label{eq:cond_distribution}
\end{equation}
```
\scriptsize $f_l (x_t | x_{t-l})$ is the conditional pdf of $X_t$ with respect to the $l$th transition kernel given that ${X}_{t-l} = {x}_{t-l}$. $w_l$ are weight parameters, where $w_l \geq 0$ such that $\sum_{l=1}^L w_l = 1$.

. . .

\normalsize

There are two components in (2):

  - Transition kernel, $f_l$, captures the influence of the $l$th lag value on the current value.  
  
  - Weight parameter, $w_l$, determines the relative contribution of that influence. 

--- 

![](images/financial.jpg){.absolute top=0 left=0 width="1200" height="675"}

<div style="margin-top: 725px;">
¬©Ô∏è Yuvraj Deshmukh
‚è≠Ô∏è Copula
</div>

## Copula 

Copula is widely used for dependence modeling.

  - Is applied in quantitative finance, reliability engineering, hydrology, etc.

  - Consists of families of copula, constituting a substantial research area.

. . .

Copula is a multivariate cumulative distribution function (cdf) where its marginal distribution of each random variables is $Unif(0, 1)$. 

. . .

Using copula, any joint distribution, $F$, can be decomposed into two parts: the copula, $C$, and the marginal distributions, $F_j$, $j = 1,..., p$.

- Rooted in Sklar‚Äôs theorem. 
  

## Existing Method to Proposed Method 

The bivariate distribution approach, for example, identifies a bivariate distribution of $(U_l, V_l)$ such that the marginal densities, $f_{U_l}$ and $f_{V_l}$, are equal to a pre-specified stationary marginal density $f_X$ for all $l$ transition kernels. 

- Based on Proposition 1 of Zheng et al. (2022).

. . .

This is facilitated by the use of a copula, which separates the marginal behavior of the random variables from their dependence structure. 

$$
\textbf{transition kernel} \longleftarrow \textbf{copula} \times \textbf{marginal} 
$$
$$
\ f_l (x_t | x_{t-l}) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ c_l (x_t, x_{t-l}) \ \ \ \ f_X (x_t) 
$$

## Proposed Method  

Replace $f_{U_l}$ and $f_{V_l}$ with a pre-specified stationary marginal density, $f_X$, for every $x_t$ and for all $l$. For $t > L$, the proposed copula-based MTD model specifies the conditional distribution as
```{=latex}
\begin{equation}
f(x_t | \textbf{x}^{t-1}) = \sum_{l=1}^L w_l c_l (x_t, x_{t-l}) f_X(x_t). \tag{3}
\label{eq:cond_distribution_copula}
\end{equation}
```
\scriptsize $c_l (x_t, x_{t-l})$ is the copula density evaluated at $x_t$ and $x_{t-l}$, and $f_X(x_t)$ is the stationary marginal density evaluated at $x_t$. 

. . .

\normalsize

Compared to (2), the transition kernel, $f_l$, is now replaced by two components: 

  - Copula density, $c_l$, captures and controls the strength of the dependence through a dependence parameter.
  
  - Stationary marginal density, $f_X$, describes the marginal behavior through distribution parameters.


## Background: Bayesian Implementation  

Earlier MTD models were built through frequentist approaches. 

Estimation and prediction in the MTD model by Zheng et al. (2022) is constructed with Bayesian methodologies. 

- Our proposed copula-based MTD model builds upon this model version. 
  
- We consider the Gaussian copula with Gamma marginals, i.e., Gamma MTD model. 

  - But the framework is generalizable, e.g., Lognormal MTD model or for any continuous distribution. 

## Background: Bayesian Implementation  

Inference is facilitated through a set of latent variables ${\{Z_t\}}_{t=L+1}^n$. $Z_t = l$ indicates which $l$th kernel the data belongs to. 

The posterior distribution of the parameters, based on the conditional likelihood, is
```{=latex} 
\begin{equation}
\begin{split}
p(\boldsymbol{w}, \boldsymbol{\theta}, {\{z_t\}}_{t=L+1}^n | D_n) \propto \pi_w(\boldsymbol{w}) \prod_{l=1}^L \pi_l(\boldsymbol{\theta}_l) \\ 
\prod_{t=L+1}^n \Biggl\{ f_{z_t} (x_t | x_{t-z_t}, \boldsymbol{\theta}_{z_t}) \sum_{l=1}^L w_l \delta_l(z_t) \Biggl\}.
\end{split} \tag{4}
\end{equation}
```
\scriptsize $\boldsymbol{w}$ is the mixture weights. $\boldsymbol{\theta}$ collects parameters for the transition kernel. $D_n = {\{x_t\}}_{t=L+1}^n$ is the data.

. . .

\normalsize 

With priors specifications, the full simulation-based Bayesian estimation and prediction can be achieved using Markov chain Monte Carlo (MCMC) algorithms. 

## Simulation Studies  

We have assessed accuracy and performance of the proposed model. 

- Convergence Diagnostics ($\boldsymbol{w}$, $\boldsymbol{\rho}$, $\alpha$, $\beta$)

- Weight and Dependence Parameters for Copula ($\boldsymbol{w}$, $\boldsymbol{\rho}$)

- Parameters for Marginal Distribution ($\alpha$, $\beta$)

. . .

Simulation studies demonstrate promising results across various scenarios. 

- Scenario 1 and 2: Default setup; Compatible $\boldsymbol{w}$ and $\boldsymbol{\rho}$

- Scenario 1.3 and 1.4: Incompatible $\boldsymbol{w}$ and $\boldsymbol{\rho}$

- Scenario 1.5 and 1.6: Compatible $\boldsymbol{w}$ and $\boldsymbol{\rho}$; Rarely observable patterns

- Scenario 3-6: Usual case for gamma marginals

- Scenario 7-9: Unusual case involving high skewness

## Weight and Dependence Parameters for Copula [^wrho]

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### Exponentially decreasing weights (s1)

```{r}
w_raw = readRDS(file.path(output_dir, "gamma_w.rds"))
rho_raw = readRDS(file.path(output_dir, "gamma_rho.rds"))
grid.arrange(w_raw, rho_raw, nrow = 1)
```

### Uneven arrangement of the relevant lags (s2)

```{r}
w_raw = readRDS(file.path(output_dir, "gamma_w_s2.rds"))
rho_raw = readRDS(file.path(output_dir, "gamma_rho_s2.rds"))
grid.arrange(w_raw, rho_raw, nrow = 1)
```

:::

[^wrho]: Four other $\boldsymbol{w}$ and $\boldsymbol{\rho}$ patterns (s1.3-1.6) are omitted here. 

## Marginal Distribution

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### Usual Cases (s3-6)
```{r}
readRDS(file.path(output_dir, "gamma_nonextreme.rds"))
```

### Unusual Cases (s7-9)

```{r}
readRDS(file.path(output_dir, "gamma_extreme.rds"))
```

::: 

# What's New  

## Sensitivity Analysis [^sensitivity] 

Since the preliminary exam, we have also conducted: 

- Sensitivity Analysis 

- Coverage Assessment. 

. . .

Sensitivity Analysis

- Use five different sets of priors (i.e., fix one parameter, and vary the other with informative, diffuse or shifted prior) and check for convergence. 

- Results appear reasonable, and the estimates are consistent with the true values, indicating that the model is robust to the choice of prior. 

[^sensitivity]: See Supplement for more. 

## Coverage Assessment 

Coverage Assessment

- Simulate $40$ replicates, combine $4$ chains of $8,000$ samples, calculate $95\%$ CI, and record whether the true parameter value falls within this interval. 

- Most parameters achieve full coverage, with a few slightly below $1$, indicating that the credible intervals reliably capture the true parameter values. 

## Coverage Assessment for Scenario 1 and 2, 40 Replicates [^coveragerate]

::: {.panel-tabset}

```{r}
library(knitr)
```

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### Exponentially decreasing weights (s1)

```{r}
df <- readRDS(file.path(output_dir, "coverage_df_s1.rds"))
df <- df |> kable(digits = 4)
df 
```

### Uneven arrangement of the relevant lags (s2)

```{r}
df <- readRDS(file.path(output_dir, "coverage_df_s2.rds"))
df <- df |> kable(digits = 4)
df 
```

::: 

[^coveragerate]: See Supplement for more. 

# Part II Models for Forecasting Zero-Inflated Skewed Time Series {background-color="#D73F09" color="white"}

## Introduction  

Zero-inflated data are characterized by an excess of zero values and  frequently appear in domains such as healthcare, insurance, environment, and transportation. 

Examples include 

- medical costs, 

- insurance claims, 

- precipitation amounts, and 

- safety measures.

If left unaddressed, zero-inflation undermines model robustness and weakens inference.

## Introduction and Objectives 

In Part I, we propose the copula-based Gamma MTD model, which enables flexible dependence modeling and accommodates arbitrary continuous marginals. 

However, 

- it remains limited in handling excessive zeros commonly observed in real-world continuous data. 

- Copula-based approaches face identifiability issues when modeling discrete or mixed marginals.

. . .

> **Objectives:** Propose reconstructing the marginal distribution to accommodate zero-inflation, while maintaining the same effectiveness and flexibility in modeling dependence structures as described in Part I.

. . .

> Develop the ZIGamma MTD model, but the framework is again generalizable.

## Background

There are two classes of models designed to handle data with excessive zeros: zero-inflated (ZI) models and hurdle models.

- In ZI models, zeros can come from both binary and non-zero parts, whereas in hurdle models, zeros occur only in the binary part.

. . .

Our approach is similar to hurdle models, but ours applies a soft threshold that replaces zeros with small non-zero values rather than generating exact zeros.

- Based on the continuous extension (CE) approach by Denuit and Lambert (2005). 

. . .

The CE approach

- Associates each discrete random variable (RV), $Y_i$, with a continuous RV, $Y_i^*$. 

- Has only applied in discrete and spatial settings to date.  

## Proposed Method  

To construct zero-inflated Gamma for the marginal distribution, 

- The Gamma distribution is first reparametrized in terms of the mean, $\mu$, and the scale parameter, $\beta$. 

. . .

- Zero values are then replaced with non-zero values drawn from a uniform distribution. 

Specifically,
```{=latex} 
\begin{equation}
0 \leftarrow U_i, \tag{5}
\end{equation}
```
where $U_i$ follows a continuous uniform distribution on $(0, \epsilon)$ with $\epsilon$ is a data-driven paramater representing the smallest observed non-zero values. 

## Proposed Method  

The resulting distribution, denoted as $ZIGamma(\mu, \beta, P, \epsilon)$, is expressed as:
```{=latex} 
\begin{equation}
f(x) = 
\begin{cases} 
Unif(0, \epsilon) & \text{with probability } P \\
ShiftedGamma(\mu, \beta; \epsilon) & \text{with probability } 1-P, 
\end{cases} \tag{6}
\end{equation}
```
where $\mu$ denotes the mean and $\beta$ the scale parameter of the shifted Gamma distribution, $P \in [0, 1]$ the zero-inflated probability, and $\epsilon > 0$ the threshold parameter. 

. . .

In (6), there are two parts: 

- We have already discussed the uniform distribution. 

- The shifted Gamma distribution, $ShiftedGamma(\mu, \beta; \epsilon)$, is a standard Gamma distribution with mean $\mu$ and scale $\beta$ that is shifted to the right by $\epsilon$, with the support $[\epsilon, \infty)$. 

## dzig (pdf of zigamma)  

::: {.panel-tabset}

```{r}
#| echo: false
dsgamma <- function(x, mu, beta, eps, logd = FALSE) {
  #(y>=epsilon)*dgamma(y-epsilon,shape=mu/beta,scale=beta)               # Nick's
  ifelse(x >= eps,                                                       # ifelse because x is a vec.
         dgamma(x - eps, shape = mu / beta, scale = beta, log = FALSE), 0)
}

dzig <- function(x, mu, beta, eps, Pi, logd = FALSE) {
  #Pi*dunif(y,0,epsilon) + (1-Pi)*dsgamma(y,mu,beta,epsilon)             # Nick's
  density <- Pi * dunif(x, 0, eps, log = FALSE) + (1-Pi) * dsgamma(x, mu, beta, eps, log = FALSE) 
  if (logd){
    return(log(density))
  } else{
    return(density)
  }
}
```

```{r}
#| echo: false
plot_dzig <- function(mu, beta, eps, Pi, y_lim){
  x <- seq(0, 25, length.out = 500)
  y <- dzig(x, mu = mu, beta = beta, eps = eps, Pi = Pi)
  df <- data.frame(
    x = x, 
    density = y
  )
  ggplot(df, aes(x = x, y = density)) +
    geom_line(size = 1) + 
    labs(x = bquote("dzig("~ 
                mu == .(mu) * " " ~ 
                beta == .(beta) * " " ~ 
                P == .(Pi) * " " ~ 
                epsilon == .(eps) *")"), 
         caption = "") + 
    ylim(0, y_lim) + 
    theme_bw(base_size = 32) + 
    theme(
      plot.margin = unit(c(1, 1, 1, 1), "cm"),      
      axis.title.x = element_text(size = 32), 
      axis.title.y = element_text(size = 32), 
      axis.text.x = element_text(size = 32), 
      axis.text.y = element_text(size = 32), 
      plot.caption = element_text(size = 32, hjust = 0) 
    ) -> p
  return (p)
}
```

### $P = 0.1$ $\epsilon = 0.1$
```{r}
#| echo: false
plot_dzig(mu = 7, beta = 1, Pi = 0.1, eps = 0.1, y_lim = 1)
```

### $P = 0.1$ $\epsilon = 0.4$

```{r}
#| echo: false
plot_dzig(mu = 7, beta = 1, Pi = 0.1, eps = 0.4, y_lim = 1)
```

### $P = 0.5$ $\epsilon = 0.1$

```{r}
#| echo: false
plot_dzig(mu = 7, beta = 1, Pi = 0.5, eps = 0.1, y_lim = 5)
```

### $P = 0.5$ $\epsilon = 0.4$

```{r}
#| echo: false
plot_dzig(mu = 7, beta = 1, Pi = 0.5, eps = 0.4, y_lim = 5)
```

### $P = 0.7$ $\epsilon = 0.1$

```{r}
#| echo: false
plot_dzig(mu = 7, beta = 1, Pi = 0.7, eps = 0.1, y_lim = 7)
```

### $P = 0.7$ $\epsilon = 0.4$

```{r}
#| echo: false
plot_dzig(mu = 7, beta = 1, Pi = 0.7, eps = 0.4, y_lim = 7)
```

:::

## pzig (cdf of zigamma)  

::: {.panel-tabset}

```{r}
#| echo: false
psgamma <- function(x,mu,beta,eps) { 
  (x>=eps)*pgamma(x-eps,shape=mu/beta,scale=beta) 
}

pzig <- function(x,mu,beta,eps,Pi) { 
  Pi*punif(x,0,eps) + (1-Pi)*psgamma(x,mu,beta,eps) 
}
```

```{r}
#| echo: false
plot_pzig <- function(mu, beta, eps, Pi){
  x <- seq(0, 25, length.out = 500)
  y <- pzig(x, mu = mu, beta = beta, eps = eps, Pi = Pi)
  df <- data.frame(
    x = x, 
    probability = y
  )
  ggplot(df, aes(x = x, y = probability)) +
    geom_line(size = 1) + 
    labs(x = bquote("pzig("~ 
                    mu == .(mu) * " " ~ 
                    beta == .(beta) * " " ~ 
                    P == .(Pi) * " " ~ 
                    epsilon == .(eps) * ")"), 
         caption = "") + 
    theme_bw(base_size = 32) + 
    theme(
      plot.margin = unit(c(1, 1, 1, 1), "cm"),      
      axis.title.x = element_text(size = 32), 
      axis.title.y = element_text(size = 32), 
      axis.text.x = element_text(size = 32), 
      axis.text.y = element_text(size = 32)
      #plot.caption = element_text(size = 18, hjust = 0) 
    ) -> p
  return (p)
}
```

### $P = 0.1$ $\epsilon = 0.1$
```{r}
#| echo: false
plot_pzig(mu = 7, beta = 1, Pi = 0.1, eps = 0.1)
```

### $P = 0.1$ $\epsilon = 0.4$

```{r}
#| echo: false
plot_pzig(mu = 7, beta = 1, Pi = 0.1, eps = 0.4)
```

### $P = 0.5$ $\epsilon = 0.1$

```{r}
#| echo: false
plot_pzig(mu = 7, beta = 1, Pi = 0.5, eps = 0.1)
```

### $P = 0.5$ $\epsilon = 0.4$

```{r}
#| echo: false
plot_pzig(mu = 7, beta = 1, Pi = 0.5, eps = 0.4)
```

### $P = 0.7$ $\epsilon = 0.1$

```{r}
#| echo: false
plot_pzig(mu = 7, beta = 1, Pi = 0.7, eps = 0.1)
```

### $P = 0.7$ $\epsilon = 0.4$

```{r}
#| echo: false
plot_pzig(mu = 7, beta = 1, Pi = 0.7, eps = 0.4)
```

:::

--- 

![](images/hpc-3.jpg){.absolute top=0 left=0 width="1200" height="675"}

<div style="margin-top: 725px;">
¬©Ô∏è FSP Group
üôè OSU Advanced Research Computing Services
</div>

## Simulation Setting   

Simulated data: 

- With weight $\boldsymbol{w}$, dependence for Gaussian copula $\boldsymbol{\rho}$, mean $\mu$, scale $\beta$, zero-inflated probability $P$, and threshold parameter $\epsilon$, we generate $n = 2000$ observations from the copula-based ZIGamma MTD model.

Model fitting: 

- Set the order $L = 5$ and consider the Gaussian copula with Gamma marginals.

MCMC setting: 

- Run the Gibbs sampler for $165, 000$ iterations, discard the first $5000$ iterations as burn-in, and collect samples every $20$ iterations.

- Run four MCMC chains with $8000$ iterations each for all of the following scenarios. 

## Simulation Studies   

We have assessed accuracy and performance of the proposed model.

- Convergence Diagnostics ($\boldsymbol{w}$, $\boldsymbol{\rho}$, $\mu$, $\beta$, $P$, $\epsilon$)

- Weight and Dependence Parameters for Copula ($\boldsymbol{w}$, $\boldsymbol{\rho}$)

- Parameters for Marginal Distribution ($\mu$, $\beta$, $P$, $\epsilon$)

Simulation studies demonstrate promising results across various scenarios. 

- Scenario 1 and 2: Default setup; Compatible $\boldsymbol{w}$ and $\boldsymbol{\rho}$

- Scenario 3-6: Usual case for zero-inflated gamma marginals

- Scenario 7-9: Unusual case involving high skewness

## Simulation Studies   

In all nine scenarios, we vary $P$ and $\epsilon$, resulting in six cases per scenario: 

- $P = 0.1$, $\epsilon = 0.1$

- $P = 0.1$, $\epsilon = 0.4$

- $P = 0.5$, $\epsilon = 0.1$

- $P = 0.5$, $\epsilon = 0.4$

- $P = 0.7$, $\epsilon = 0.1$

- $P = 0.7$, $\epsilon = 0.4$

For brevity, we present Scenario 1 only.

## Simulation Results [^res]  

```{r}
library(coda)
```

```{r}
data_dir <- "/Users/franceslin/Downloads/code_mtd_v17_b3/data-test-cluster-cdp"
```

```{r}
chain1 = readRDS(file.path(data_dir, "chain1_iter8000.rds"))
chain2 = readRDS(file.path(data_dir, "chain2_iter8000.rds"))
chain3 = readRDS(file.path(data_dir, "chain3_iter8000.rds"))
chain4 = readRDS(file.path(data_dir, "chain4_iter8000.rds"))
```

```{r}
mcmc_chains <- function(chain_list, parameter, index) {
  # Function to create and analyze mcmc chains FOR RHO ONLY
  mcmc_list <- lapply(chain_list, function(chain) {
    chain[[parameter]][index, ] %>% mcmc()
  })
  
  mcmc_chains <- mcmc_list %>% as.mcmc.list()
  
  return(mcmc_chains)
}
```

```{r}
set.seed(42)
mtdorder <- 5
expDecay <- function(x, la) exp(-la*x)
weight <- expDecay(1:mtdorder, 1)
weight_vec <- weight / sum(weight)
weight_vec <- weight_vec %>% round(digits = 4)
```

::: {.panel-tabset}

### $P = 0.1$ $\epsilon = 0.1$

```{r}
chain_list <- list(chain1, chain2, chain3, chain4)
Point_est <- numeric(5)
Upper_ci <- numeric(5)
Gelman_Rubin <- character(5)
Mean <- numeric(5)
SD <- numeric(5)
Summary <- character(5)
Naive_SE <- numeric(5)
Time_series_SE <- numeric(5)

for (weight in 1:5) {
  result <- mcmc_chains(chain_list, "weight", weight)
  diag_result <- result %>% gelman.diag()
  
  # Extract the psrf matrix
  psrf_matrix <- diag_result$psrf
  
  # Store point estimates and upper CI 
  Point_est[weight] <- psrf_matrix[1, "Point est."] %>% round(digits = 2)
  Upper_ci[weight] <- psrf_matrix[1, "Upper C.I."] %>% round(digits = 2)
  # Change format 
  Gelman_Rubin[weight] <- paste(Point_est[weight], " (", Upper_ci[weight], ")", sep = "")
  
  r <- result %>% summary()
  Mean[weight]  <- r$statistics[[1]] %>% round(digits = 4)
  SD[weight]  <- r$statistics[[2]] %>% round(digits = 4)
  # Change format 
  Summary[weight] <- paste(Mean[weight], " (", SD[weight], ")", sep = "")
  
  Naive_SE[weight]  <- r$statistics[[3]]
  Time_series_SE[weight]  <- r$statistics[[4]]
}

results_df_w <- tibble(
  `.` = sprintf("$w_%d = %.3f$", 1:5, weight_vec), #= paste0("$w_", 1:5, "$"), 
  #point_est = point_est %>% round(digits = 2),
  #upper_ci = upper_ci %>% round(digits = 2), 
  `Mean (SD)` = Summary, 
  `R (Upper CI)` = Gelman_Rubin, 
  #mean = Mean %>% round(digits = 4), 
  #sd = SD %>% round(digits = 4), 

  `Naive SE` = Naive_SE %>% round(digits = 4), 
  `Time-series SE` = Time_series_SE %>% round(digits = 4)
)
results_df_w <- results_df_w |> kable(digits = 4)
results_df_w
```

### $P = 0.1$ $\epsilon = 0.1$

```{r}
mcmc_chains <- function(chain_list, parameter, index) {
  # Function to create and analyze mcmc chains FOR RHO ONLY
  mcmc_list <- lapply(chain_list, function(chain) {
    chain[[parameter]][index, ] %>% mcmc()
  })
  
  mcmc_chains <- mcmc_list %>% as.mcmc.list()
  
  return(mcmc_chains)
}
```

```{r}
rho_vec = c(0.7, 0.5, 0.3, 0.1, 0.1)
```

```{r}
chain_list <- list(chain1, chain2, chain3, chain4)
Point_est <- numeric(5)
Upper_ci <- numeric(5)
Gelman_Rubin <- character(5)
Mean <- numeric(5)
SD <- numeric(5)
Summary <- character(5)
Naive_SE <- numeric(5)
Time_series_SE <- numeric(5)

for (rho in 1:5) {
  result <- mcmc_chains(chain_list, "rho", rho)
  diag_result <- result %>% gelman.diag()
  
  # Extract the psrf matrix
  psrf_matrix <- diag_result$psrf
  
  # Store point estimates and upper CI 
  Point_est[rho] <- psrf_matrix[1, "Point est."] %>% round(digits = 2)
  Upper_ci[rho] <- psrf_matrix[1, "Upper C.I."] %>% round(digits = 2)
  # Change format 
  Gelman_Rubin[rho] <- paste(Point_est[rho], " (", Upper_ci[rho], ")", sep = "")
  
  r <- result %>% summary()
  Mean[rho]  <- r$statistics[[1]] %>% round(digits = 4)
  SD[rho]  <- r$statistics[[2]] %>% round(digits = 4)
  # Change format 
  Summary[rho] <- paste(Mean[rho], " (", SD[rho], ")", sep = "")
  
  Naive_SE[rho]  <- r$statistics[[3]]
  Time_series_SE[rho]  <- r$statistics[[4]]
}

results_df_rho <- tibble(
  `.` = sprintf("$\\rho_%d = %.3f$", 1:5, rho_vec), 
  #point_est = point_est %>% round(digits = 2),
  #upper_ci = upper_ci %>% round(digits = 2), 
  `Mean (SD)` = Summary, 
  `R (Upper CI)` = Gelman_Rubin, 
  #mean = Mean %>% round(digits = 4), 
  #sd = SD %>% round(digits = 4), 
  `Naive SE` = Naive_SE %>% round(digits = 4), 
  `Time-series SE` = Time_series_SE %>% round(digits = 4)
)
results_df_rho <- results_df_rho |> kable(digits = 4)
results_df_rho
```

::: 

[^res]: $\boldsymbol{w}$, $\boldsymbol{\rho}$ for all other combinations of $P = 0.1, 0.5, 0.7$ and $\epsilon = 0.1, 0.4$ are similar and therefore omitted.

## Simulation Results   

```{r}
make_table_mar <- function(chain1, chain2, chain3, chain4) {
  
  mcmc_chains <- function(chain_list, parameter) {
    # Create and analyze mcmc chains
    mcmc_list <- lapply(chain_list, function(chain) {
      chain[[parameter]] %>% mcmc()
    })
    
    return(mcmc_list %>% as.mcmc.list())
  }
  
  conv_table <- function(parameter) {
    chain_list <- list(chain1, chain2, chain3, chain4)
    result <- mcmc_chains(chain_list, parameter)
    
    diag_result <- result %>% gelman.diag()
    psrf_matrix <- diag_result$psrf
    Point_est <- psrf_matrix[1, "Point est."] %>% round(digits = 2)
    Upper_ci <- psrf_matrix[1, "Upper C.I."] %>% round(digits = 2)
    Gelman_Rubin <- paste0(Point_est, " (", Upper_ci, ")")
    
    r <- result %>% summary()
    Mean <- r$statistics[1] %>% round(digits = 4)
    SD <- r$statistics[2] %>% round(digits = 4)
    Summary <- paste0(Mean, " (", SD, ")")
    Naive_SE <- r$statistics[3] %>% round(digits = 4)
    Time_series_SE <- r$statistics[4] %>% round(digits = 4)
    
    # Display names based on parameter
    param_display <- switch(
      parameter,
      "shape1" = "$\\mu$",
      "shape2" = "$\\beta$",
      "Pi" = "$P$",
      "$\\epsilon$" # default
    )
    
    results_df <- tibble(
      `.` = param_display,
      `Mean (SD)` = Summary, 
      `R (Upper CI)` = Gelman_Rubin, 
      `Naive SE` = Naive_SE, 
      `Time-series SE` = Time_series_SE
    )
    
    return(results_df)
  }
  
  results_alp <- conv_table("shape1")
  results_be <- conv_table("shape2")
  results_Pi <- conv_table("Pi")
  results_eps <- conv_table("eps")
  
  results_df_mar <- bind_rows(results_alp, results_be, results_Pi, results_eps)
  
  results_df_mar <- results_df_mar |> kable(digits = 4)

  return(results_df_mar) 
}
```

```{r}
data_dir <- "/Users/franceslin/Downloads/code_mtd_v17_b3/data-test-cluster-cdp"
```

```{r}
chain1 = readRDS(file.path(data_dir, "chain1_iter8000.rds"))
chain2 = readRDS(file.path(data_dir, "chain2_iter8000.rds"))
chain3 = readRDS(file.path(data_dir, "chain3_iter8000.rds"))
chain4 = readRDS(file.path(data_dir, "chain4_iter8000.rds"))
t1 = make_table_mar(chain1, chain2, chain3, chain4)
chain1 = readRDS(file.path(data_dir, "chain1_iter8000_eps04.rds"))
chain2 = readRDS(file.path(data_dir, "chain2_iter8000_eps04.rds"))
chain3 = readRDS(file.path(data_dir, "chain3_iter8000_eps04.rds"))
chain4 = readRDS(file.path(data_dir, "chain4_iter8000_eps04.rds"))
t2 = make_table_mar(chain1, chain2, chain3, chain4)
p <- "05"
chain1 <- readRDS(file.path(data_dir, paste0("chain1_iter8000_p", p, ".rds")))
chain2 <- readRDS(file.path(data_dir, paste0("chain2_iter8000_p", p, ".rds")))
chain3 <- readRDS(file.path(data_dir, paste0("chain3_iter8000_p", p, ".rds")))
chain4 <- readRDS(file.path(data_dir, paste0("chain4_iter8000_p", p, ".rds")))
t3 = make_table_mar(chain1, chain2, chain3, chain4)
p <- "05"
eps <- "04"
chain1 = readRDS(file.path(data_dir, paste0("chain1_iter8000_p", p, "_eps", eps, ".rds")))
chain2 = readRDS(file.path(data_dir, paste0("chain2_iter8000_p", p, "_eps", eps, ".rds")))
chain3 = readRDS(file.path(data_dir, paste0("chain3_iter8000_p", p, "_eps", eps, ".rds")))
chain4 = readRDS(file.path(data_dir, paste0("chain4_iter8000_p", p, "_eps", eps, ".rds")))
t4 = make_table_mar(chain1, chain2, chain3, chain4)
p <- "07"
chain1 <- readRDS(file.path(data_dir, paste0("chain1_iter8000_p", p, ".rds")))
chain2 <- readRDS(file.path(data_dir, paste0("chain2_iter8000_p", p, ".rds")))
chain3 <- readRDS(file.path(data_dir, paste0("chain3_iter8000_p", p, ".rds")))
chain4 <- readRDS(file.path(data_dir, paste0("chain4_iter8000_p", p, ".rds")))
t5 = make_table_mar(chain1, chain2, chain3, chain4)
p <- "07"
eps <- "04"
chain1 = readRDS(file.path(data_dir, paste0("chain1_iter8000_p", p, "_eps", eps, ".rds")))
chain2 = readRDS(file.path(data_dir, paste0("chain2_iter8000_p", p, "_eps", eps, ".rds")))
chain3 = readRDS(file.path(data_dir, paste0("chain3_iter8000_p", p, "_eps", eps, ".rds")))
chain4 = readRDS(file.path(data_dir, paste0("chain4_iter8000_p", p, "_eps", eps, ".rds")))
t6 = make_table_mar(chain1, chain2, chain3, chain4)
```

::: {.panel-tabset}

### $P = 0.1$ $\epsilon = 0.1$

```{r}
t1
```

### $P = 0.1$ $\epsilon = 0.4$

```{r}
t2
```

### $P = 0.5$ $\epsilon = 0.1$

```{r}
t3
```

### $P = 0.5$ $\epsilon = 0.4$

```{r}
t4
```

### $P = 0.7$ $\epsilon = 0.1$

```{r}
t5
```

### $P = 0.7$ $\epsilon = 0.4$

```{r}
t6
```

:::

## Coverage Assessment

All nine scenarios were analyzed using a single replicate. 

- Recall that we have six cases per scenario.

. . .

Scenarios 1 and 2 were further evaluated with $10$ replicates to assess coverage and robustness. 

- The overall coverage is the proportion of replicates for which the true value is contained within the interval.

. . .

Most parameters achieve full coverage, with a few slightly below $1$, indicating that the posterior intervals reliably capture the true parameter values.

## Prediction, $95\%$ Predictive Intervals, One-Step Ahead  

::::: columns

::: column

### 

```{r}
library(kableExtra)
```

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
df <- readRDS(file.path(output_dir, "table_combind.rds"))
```
```{r}
df <- round(df, 4)
df[1,3] <- cell_spec(df[1,3], bold = TRUE)
df[2,3] <- cell_spec(df[2,3], bold = TRUE)
df[3,2] <- cell_spec(df[3,2], bold = TRUE)
df[4,2] <- cell_spec(df[4,2], bold = TRUE)
df[5,2] <- cell_spec(df[5,2], bold = TRUE)
df[6,2] <- cell_spec(df[6,2], bold = TRUE)
df <- df |> kable(digits = 4)
df
```

::: 

::: column

### 

::: {.incremental}

- When the zero-inflated probability is low (e.g., $P = 0.1$), the empirical coverage **above** (i.e., the coverage for data greater than $\epsilon$) is a more informative metric for assessing predictive performance. 

- As $P$ increases (e.g., $P = 0.5$, $0.7$), the empirical coverage **below** becomes increasingly dominant. 

- The model appropriately captures the predictive uncertainty across all cases. 

:::

::: 

::::: 


## Prediction, $95\%$ Predictive Intervals, One-Step Ahead  

::: {.panel-tabset}

### $P = 0.1$ $\epsilon = 0.1$

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
readRDS(file.path(output_dir, "p1.rds"))
```

### $P = 0.1$ $\epsilon = 0.4$

```{r}
readRDS(file.path(output_dir, "p2.rds"))
```

### $P = 0.5$ $\epsilon = 0.1$

```{r}
readRDS(file.path(output_dir, "p3.rds"))
```

### $P = 0.5$ $\epsilon = 0.4$

```{r}
readRDS(file.path(output_dir, "p4.rds"))
```

### $P = 0.7$ $\epsilon = 0.1$

```{r}
readRDS(file.path(output_dir, "p5.rds"))
```

### $P = 0.7$ $\epsilon = 0.4$

```{r}
readRDS(file.path(output_dir, "p6.rds"))
```

::: 

# Part III Copula-Based Markov MTD Models vs. Deep Learning LSTM Networks {background-color="#D73F09" color="white"} 

## Introduction   

Recurrent Neural Networks (RNNs), and their variants, Long Short-Term Memory (LSTMs), are widely used for modeling sequence data because of their ability to capture both short- and long-term dependencies.

. . .

Beyond natural language processing (NLP), RNNs and LSTMs have also shown effective in time series forecasting and have been employed for applications including

- financial market prediction, 

- energy forecasting,

- weather and climate modeling, and

- epidemiological trend analysis.

## Introduction and Objectives  

However, 

- previous studies comparing LSTMs to traditional models such as ARIMA often claim LSTM superiority, a conclusion that can be misleading when the benchmarks chosen are inappropriate.

- A prior study found comparable performance between the MTD model and the LSTM network for predicting disease spread.

. . .

> **Objectives:** Evaluate LSTM and MTD models to ensure a fair and balanced comparison of their performance and robustness. 

. . .

> Demonstrate that our proposed MTDs outperform LSTMs in accuracy, though at a higher computational cost and the need for careful design. 

## RNN (Recurrent Neural Network)

::::: columns

::: column

### 

![Architecture of an RNN unit, reproduced from Olah (2015). $x_t$ is the input, $h_t$ is the hidden state, and $o_t$ is the output. $tanh$ is the activation function, squashing values to $(-1, 1)$ for stability and zero-centered output.](images/rnn.png)

::: 

::: column

### 

- An RNN unit computes a weighted combination of input data, $x_t$, and the previous hidden state, $h_{t-1}$, applies an activation function, and updates the hidden state to $h_t$. 

- RNN is composed of repeating units that unfold over time, where each unit passes recurrent information stored in the hidden state from one time step to the next. 

- RNN is prone to the well-documented vanishing gradient issue when processing long sequences. 

::: 

::::: 

## LSTM (Long Short-Term Memory)

::::: columns

::: column

### 

![Architecture of an LSTM unit with a forget gate, reproduced from Olah (2015). $x_t$ is the input, $h_t$ the hidden state, and $c_t$ the cell state. $f_t$, $i_t$, and $o_t$ are the forget, input, and output gates, respectively. $\sigma$ is used to squash values to $(0, 1)$ for gating, while $tanh$ squashes values to $(-1, 1)$ for stability and zero-centered output.](images/lstm.png)

::: 

::: column

### 

- LSTM extends RNN by introducing a cell state and three gates: the forget gate, the input gate, and the output gate. 

- The cell state carries long-term dependence, while the hidden state encodes short-term patterns. 

- The gates control information flow, deciding what to forget, add, and pass to the hidden state at each step.

::: 

::::: 

## Hyperparameter Tuning and Training  

Hyperparameter tuning plays a crucial role in improving model performance. Key hyperparameters include:

- batch size,

- number of epochs,

- learning rate

- number of hidden units or cell dimension, 

- number of hidden layers, etc.

. . .

The network is typically trained using Backpropagation Through Time (BPTT) and optimized with gradient-based methods such as Stochastic Gradient Descent (SGD) and Adaptive Moment Estimation (Adam). 

# Simulation Studies 

## Experimental Setup   

Experiment 1: 

- We run both models on Gamma Scenario 1‚Äì9 to compare the predictive performance of the LSTM and MTD models under various conditions. 

Experiment 2: 

- We run both models on 10 independently generated replicates of Gamma Scenario 1 to assess the stability and robustness of model performance. 

Experiment 3: 

- We run the LSTM model on 10 independently generated replicates of Gamma Scenario 1 for a variety of configurations (e.g., batch size, learning rate, cell dimention, hidden layer) to investigate the impact of hyperparameters. 

## Experimental Setup   

Experiment 4: 

- For the zero-inflated Gamma settings, we run both models on Scenario 1 and 2, since each scenario includes six cases defined by all combinations of $P = 0.1, 0.5, 0.7$, and $\epsilon = 0.1, 0.4$. 

## Simulation Results for Gamma Scenarios 1-9

::::: columns

::: column

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
df <- readRDS(file.path(output_dir, "gamma.rds"))
```
```{r}
df <- df |> mutate(across(where(is.numeric), ~round(., 4)))
df$MTD[2] <- cell_spec(df$MTD[2], bold = TRUE)
df$MTD[3] <- cell_spec(df$MTD[3], bold = TRUE)
df$MTD[4] <- cell_spec(df$MTD[4], bold = TRUE)
df$MTD[6] <- cell_spec(df$MTD[6], bold = TRUE)
df$LSTM[1] <- cell_spec(df$LSTM[1], bold = TRUE)
df$LSTM[5] <- cell_spec(df$LSTM[5], bold = TRUE)
df$LSTM[7] <- cell_spec(df$LSTM[7], bold = TRUE)
df$LSTM[8] <- cell_spec(df$LSTM[8], bold = TRUE)
df$LSTM[9] <- cell_spec(df$LSTM[9], bold = TRUE)
df <- df |> kable(digits = 4)
df
```

:::

::: column

- RMSEs for MTD are lower in Scenarios 2, 3, 4, and 6, though the differences are minimal.

- RMSEs are the highest for both models in Scenario 2. 

::: 

::::: 

## Simulation Results for Gamma Scenario 1, 10 replicates

::::: columns

::: column

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r, fig.height=10}
p <- readRDS(file.path(output_dir, "gamma_2.rds"))
print(p)
```

:::

::: column

- RMSE has a mean difference of $0.128957$ (`p-value = 0.005175`, `df = 9`), with MTD consistently yielding lower RMSEs. 

::: 

::::: 

## Simulation Results for Gamma Scenario 1, 10 replicates

::::: columns

::: column

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
p_lstm_lr <- readRDS(file.path(output_dir, "p_lstm_lr.rds"))
p_lstm_2 <- readRDS(file.path(output_dir, "p_lstm_2.rds"))
p_lstm_l <- readRDS(file.path(output_dir, "p_lstm_l.rds"))
p_lstm_cd <- readRDS(file.path(output_dir, "p_lstm_cd.rds"))
```

```{r, fig.height=10}
grid.arrange(p_lstm_lr, p_lstm_2, p_lstm_l, p_lstm_cd, ncol = 2)
```

:::

::: column

- Batch size is significant (`Pr(>F) = 4.4e-06`, `df = 2, 24`); RMSEs differ only for $64$ vs. others, and $128$ vs. others.

- Cell dimensions too (`Pr(>F) = 0.0113`, `df = 2, 24`); RMSE differs only between $32$ vs. $64$ and $32$ vs. $128$.

- We adopt the default configuration for subsequent experiments: 

  - learning rate = $0.001$, 
  
  - batch size = $32$, 
  
  - number of layers = $1$, and 
  
  - cell dimension = $64$. 

::: 

::::: 

---

![](images/zeros.jpg){.absolute top=0 left=0 width="1200" height="675"}

<div style="margin-top: 725px;">
¬©Ô∏è Akin Bostanci
‚è∏Ô∏è ... Quick Visual Break
</div>

## Simulation Results for ZIGamma Scenario 1

::::: columns

::: column

### 

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
df <- readRDS(file.path(output_dir, "zigamma.rds"))
```
```{r}
df <- df |> mutate(across(where(is.numeric), ~round(., 4)))
df$LSTM <- cell_spec(df$LSTM, bold = TRUE)
df <- df |> kable(digits = 4)
df
```

::: 

::: column

### 

- LSTM generally achieves lower overall RMSEs compared to MTD. 

- ‚ùóÔ∏èBut, patterns similar to those in Prediction of Part II reappear. 


::: 

::::: 

## Simulation Results for ZIGamma Scenario 1

::::: columns

::: column

### 

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
df <- readRDS(file.path(output_dir, "zigamma_lu.rds"))
```

```{r}
df <- df |> mutate(across(where(is.numeric), ~round(., 4)))
df$`MTD Above`[1] <- cell_spec(df$`MTD Above`[1], bold = TRUE)
df$`MTD Above`[2] <- cell_spec(df$`MTD Above`[2], bold = TRUE)
df$`MTD Below`[3] <- cell_spec(df$`MTD Below`[3], bold = TRUE)
df$`MTD Below`[4] <- cell_spec(df$`MTD Below`[4], bold = TRUE)
df$`MTD Below`[5] <- cell_spec(df$`MTD Below`[5], bold = TRUE)
df$`MTD Below`[6] <- cell_spec(df$`MTD Below`[6], bold = TRUE)
df <- df |> kable(digits = 4)
df
```

::: 

::: column

### 

::: {.incremental}

- When the zero-inflated probability is low (e.g., $P = 0.1$), the RMSE **above** (which reflects predictive accuracy for values exceeding $\epsilon$) is a more informative metric for assessing predictive performance. 

- As $P$ increases (e.g., $P = 0.5$, $0.7$), this relationship reverses, and the RMSE **below** becomes more relevant. 

- MTD outperforms LSTM in RMSE **above** for $P = 0.1$ and again yields lower values for RMSE **below** than LSTM at higher levels of zero-inflation (e.g., $P = 0.5$, $0.7$).

::: 

::: 

::::: 

# Data Application 

## Experimental Setup   

::::: columns

::: column

### MTD

- For MTD, the hyperparameter settings are:

  - marginal parameters $\alpha$, $\beta$ [^alpha]: $Gamma(\alpha | u_{\alpha}, v_{\alpha} = 1)$, $Gamma(\beta | u_{\beta}, v_{\beta} = 1)$,

  - dependence parameter $\rho$: $Unif(\rho_l | -1, 1)$, and

  - weight parameter $w$ [^w]: $CDP(w | \alpha_0 = 5, a_0 = 1, b_0 = 3)$; cdf-based Dirichlet process prior.

[^alpha]: $u_{\alpha}$, $u_{\beta}$ derived from the training data: $u_{\beta}$ = mean/variance, $u_{\alpha}$ = mean $\times$ $u_{\beta}$.

[^w]: $\alpha_0$: concentration parameter; $G_0$: base distribution, i.e., $G_0 \sim Beta(a_0, b_0)$. 

- MTD is implemented in `R` and executed on a high-performance computing (HPC) cluster. 

::: 

::: column

### LSTM

- For LSTM, we reuse the default configuration for subsequent experiments: 

  - learning rate = $0.001$, 
  
  - batch size = $32$, 
  
  - number of layers = $1$, and 
  
  - cell dimension = $64$. 

- LSTM is implemented in `PyTorch` and trained on a standard workstation.


::: 

::::: 

## Evaluation Metrics [^metrics]

| Metric| Definition | Formula |
|------|------|------|
| RMSE    | Root Mean Squared Error    | $\sqrt{\frac{1}{T} \sum_{t=1}^{T} (y_t - \hat{y}_t)^2}$   |
| MAE     | Mean Absolute Error     | $\frac{1}{T} \sum_{t=1}^{T} |y_t - \hat{y}_t|$   |
| MAPE    | Mean Absolute Percentage Error    | $\frac{100}{T} \sum_{t=1}^{T} \left| \frac{y_t - \hat{y}_t}{y_t} \right|$  |
| SMAPE   | Symmetric MAPE    | $\frac{100}{T} \sum_{t=1}^{T} \frac{|y_t - \hat{y}_t|}{(|y_t| + |\hat{y}_t|) / 2}$   |
| MASE    | Mean Absolute Scaled Error     | $\frac{ \frac{1}{T} \sum_{t=1}^{T} |y_t - \hat{y}_t| }{ \frac{1}{T - 1} \sum_{t=2}^{T} |y_t - y_{t-1}| }$  |

: {tbl-colwidths="[25, 50, 50]"}

[^metrics]: MAPE, SMAPE, and MASE are scale-independent, allowing for comparison across datasets with different units. 

# Data Application 

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### windspeeds at 50m above ground

```{r}
df <- readRDS(file.path(output_dir, "real_50.rds"))
```
```{r}
df <- df |> mutate(across(where(is.numeric), ~round(., 4)))
df$MTD <- cell_spec(df$MTD, bold = TRUE)
df <- df |> kable(digits = 4)
df
```

### windspeeds at 10m above ground

```{r}
df <- readRDS(file.path(output_dir, "real_10.rds"))
```
```{r}
df <- df |> mutate(across(where(is.numeric), ~round(., 4)))
df$MTD <- cell_spec(df$MTD, bold = TRUE)
df <- df |> kable(digits = 4)
df
```

### windspeeds at 2m above ground

```{r}
df <- readRDS(file.path(output_dir, "real_2.rds"))
```
```{r}
df <- df |> mutate(across(where(is.numeric), ~round(., 4)))
df$MTD <- cell_spec(df$MTD, bold = TRUE)
df <- df |> kable(digits = 4)
df
```

::: 

## Data Application, Predicted Means, One-Step ahead; Test Size $n = 1756$ [^caption]

::: {.panel-tabset}

### windspeeds at 50m above ground

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
readRDS(file.path(output_dir, "p1_real_ts_full.rds"))
```

### windspeeds at 10m above ground

```{r}
readRDS(file.path(output_dir, "p2_real_ts_full.rds"))
```

### windspeeds at 2m above ground

```{r}
readRDS(file.path(output_dir, "p3_real_ts_full.rds"))
```

::: 

[^caption]: Solid (black) lines are true values. Dashed (red) lines are LSTM predicted means and dashed (blue) lines are MTD predicted means.

## Data Application, Predicted Means, One-Step Ahead; Zoom-In View $n = 200$ [^caption]

::: {.panel-tabset}

### windspeeds at 50m above ground

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
readRDS(file.path(output_dir, "p1_real_ts.rds"))
```

### windspeeds at 10m above ground

```{r}
readRDS(file.path(output_dir, "p2_real_ts.rds"))
```

### windspeeds at 2m above ground

```{r}
readRDS(file.path(output_dir, "p3_real_ts.rds"))
```

::: 

[^caption]: Solid (black) lines are true values. Dashed (red) lines are LSTM predicted means and dashed (blue) lines are MTD predicted means.

## Data Application, Prediction Errors, One-Step Ahead; Zoom-In View $n = 200$ [^captiondiff]

::: {.panel-tabset}

### windspeeds at 50m above ground

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
readRDS(file.path(output_dir, "p1_real_diff.rds"))
```

### windspeeds at 10m above ground

```{r}
readRDS(file.path(output_dir, "p2_real_diff.rds"))
```

### windspeeds at 2m above ground

```{r}
readRDS(file.path(output_dir, "p3_real_diff.rds"))
```

::: 

[^captiondiff]: Dashed (red) lines show differences between LSTM predicted means and observed values and dashed (blue) lines show differences between MTD predicted means and observed values.

## Data Application, $95\%$ Predictive Intervals, One-Step Ahead; MTD Only [^captionmtd]

::: {.panel-tabset}

### windspeeds at 50m above ground

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
readRDS(file.path(output_dir, "p1_real.rds"))
```

### windspeeds at 10m above ground

```{r}
readRDS(file.path(output_dir, "p2_real.rds"))
```

### windspeeds at 2m above ground

```{r}
readRDS(file.path(output_dir, "p3_real.rds"))
```

::: 

[^captionmtd]: Empirical coverage is particularly relevant and can only be assessed with probabilistic forecasting methods such as MTD.

---

![](images/conclusion-3.jpg){.absolute top=0 left=0 width="1200" height="675"}

<div style="margin-top: 725px;">
¬©Ô∏è Getty Images
‚èØÔ∏è Conclusion
</div>

## Conclusion

Part I and II 

We develop a novel copula-based MTD model that separates the dependence structure from the marginal distribution. This separation 

- Enables a choice of copula families that effectively capture dependence.

- Provides flexibility in marginal selection.

We also develop a copula-based zero-inflated MTD model, which preserves the advantages of copula modeling for capturing dependence in zero-inflated continuous settings. 

- This extension again demonstrates the framework‚Äôs generalizability beyond the Gamma marginals.

## Conclusion

Part III

Through simulation studies and real-world applications, we illustrate how MTD and LSTM serve as complementary approaches for modeling complex, skewed, and zero-inflated time series. 

- MTD models provide more robust and explainable temporal modeling but come at the cost of increased computational complexity and more involved model design. 

- LSTMs offer general-purpose modeling and computational efficiency, but their black-box nature can limit interpretability and, in some cases, reduce accuracy.

Overall, the proposed MTD framework provides a flexible, robust, and interpretable approach for modeling complex continuous and zero-inflated time series, demonstrating superior performance compared to LSTM in the settings considered. 

---

![](images/future.jpg){.absolute top=0 left=0 width="1200" height="675"}

<div style="margin-top: 725px;">
¬©Ô∏è Shutterstock
‚èØÔ∏è Future Work
</div>

## Future Work

Part I and II

- Both Gamma MTD and ZIGamma MTD models use Gaussian copula to model dependence. Future work should explore alternative copulas, like Clayton and Gumbel, to capture tail dependence and asymmetry, and assess their impact on model performance.

- Although the current framework assumes stationarity and does not incorporate covariates/features, it can be easily extended to enhance flexibility and realism in modeling complex temporal patterns.

## Future Work

Part III

- Given the growing prominence of transformer architectures in sequence modeling, further research should extend performance comparisons to include transformer-based models.  

- It is equally important to ensure that evaluations are conducted using appropriate benchmarks and metrics.

# Thank you!

## Acknowledgement

## References 

# Supplement

## Copula CDF and PDF

![](images/copula-2.png){.absolute top=150 left=250 width="780" height="360"}

<div style="margin-top: 650px;">
Wireframe plot of bivariate Gaussian distribution and density function, reproduced from Kenton (2024). Retrieved from https://www.investopedia.com/terms/c/copula.asp.
</div>

## Copula Families 

![](images/copula_fam-2.png){.absolute top=100 left=0 width="1200" height="600"}

<div style="margin-top: 650px;">
Contour plot of different bivariate density function where marginals are $N(0, 1)$, reproduced from Chang (2019). Retrieved from https://bochang.me/blog/posts/copula/. 
</div>

## Copula: Sklar‚Äôs theorem

::: {.proposition #prop-copula}
For any $p$-dimensional multivariate cumulative distribution function (cdf) of a random vector $(X_1, ..., X_p)$, denoted as $F(x_1, ..., x_p)$, there exists a copula function $C: {[0,1]}^p \rightarrow [0, 1]$ for which $F(x_1, ..., x_p) = C(F_1(x_1), ..., F_p(x_p))$, where $F_j$ is the marginal cdf of $X_j, j = 1,..., p$. If $X_j$ is continuous for all $j$, then $C$ is unique and differentiable. The joint probability density function (pdf) of $X_j, j = 1,...,p$ is given by $f(x_j) = c(x_j) \prod_{j=1}^p f_j(x_j)$, where $c = \partial^p{C} / \partial{F_j}$ is the copula density and $f_j$ is the density of $X_j$.
::: 

## Proposition 1: Zheng et al. (2022)'s invariant condition

::: {.proposition #prop-1}
Consider a set of bivariate random vectors $(U_l, V_l)$ that takes values in $S \times S \subset \mathbb{R}$. Consider a time series $\{ X_t: t \in \mathbb{N} \}$, where $X_t \in S$, generated from
$$
f(x_t | \textbf{x}^{t-1}) = \sum_{l=1}^L w_l f_{U_l|V_l} (x_t | x_{t-l}), t > L, 
$$
and from 
$$
f(x_t | \textbf{x}^{t-1}) = \sum_{l=1}^{t-2} w_l f_{U_l|V_l} (x_t | x_{t-l}) + 
\left( 1 - \sum_{k=1}^{t-2} w_k \right) f_{U_{t-1} | V_{t-1}} (x_t|x_1), 2 \leq t \leq L.
$$

If a time series satisfies the invariant condition: $X_1 \sim f_X$, and $f_{U_l}(x) = f_{V_l}(x) = f_X(x)$, for all $x \in S$, and for all $l$, then this time time series is first-order strictly stationary with invariant marginal density $f_X$.
::: 

## Algorithm 1: Implementaion Details 

- The full Bayesian model is complete by priors specification for the parameters $\boldsymbol{\theta} = \{\alpha, \beta, \boldsymbol{\rho}\}$ and $\boldsymbol{w}$.

- The posterior full conditional distributions:

  - For the marginal parameters $\alpha$ and $\beta$ are proportional to $Gamma(\alpha | u_{\alpha}, v_{\alpha}) \prod_{t=L+1}^n f_l (x_t | x_{t-l})$ and $Gamma(\beta | u_{\beta}, v_{\beta}) \prod_{t=L+1}^n f_l (x_t | x_{t-l})$, respectively. $f_l (x_t | x_{t-l}) = c_l (x_t, x_{t-l}) f_X(x_t)$. 
  
  - For each of the dependence parameters $\boldsymbol{\rho}$ is proportional to $Unif(\rho_l |-1, 1) \prod_{t:z_t = l} c_l (x_t, x_{t-l})$. 
  
  - For each $z_t$ of the latent variables ${\{z_t\}}_{t=L+1}^n$, where the probability of $z_t = l$, denoted by $q_l$, is proportional to $w_l c_l (x_t, x_{t-l})$, for $l = 1,..., L$. 

  - For weight parameters $\boldsymbol{w}$, under the cdf-based prior, is $Dirichlet (\boldsymbol{\alpha})$, where $\boldsymbol{\alpha} = (\alpha_0 a_1 + M_1, ..., \alpha_0 a_L + M_L)$. $a_l = G_0(l/L) - G_0((l - 1)/L)$, $M_l = |\{ t: z_t = l \}|$. 

--- 

![Asterisk (*) denotes modification of Zheng's (2022) algorithm.](images/alg-1.png){fig-align="left"}

## Algorithm 2: Implementaion Details 

- The full Bayesian model is complete by priors specification for the parameters $\boldsymbol{\theta} = \{\alpha, \beta, P, \epsilon, \boldsymbol{\rho}\}$ and $\boldsymbol{w}$.

- The posterior full conditional distributions:

  - (Same as Gamma MTD)

  - For the zero-inflated probability $P$, is proportional to $Unif(P | 0, 1) \prod_{t=L+1}^n f_l (x_t | x_{t-l})$.

  - For the threshold parameter $\epsilon$, is proportional to $ScaledBeta(5, 5; 0, 2\epsilon_0) \prod_{t=L+1}^n f_l (x_t | x_{t-l})$.




--- 

![Asterisk (**) denotes modification of Algorithm 1.](images/alg-2.png){fig-align="left"}

## Sensitivity Analysis for Gamma Scenario 1

| Prior for $\alpha$ | Prior for $\beta$ | Description |
|------|------|------|
| $Gamma(49, 7)$    | $Gamma(1, 1)$    | Informative prior for both $\alpha$ and $\beta$. |
| $Gamma(4.9, 0.7)$ | $Gamma(1, 1)$    |Diffuse prior for $\alpha$. Informative prior for $\beta$. |
| $Gamma(49, 7)$  | $Gamma(0.1, 0.1)$ | Informative prior for $\alpha$. Diffuse prior for $\beta$. |
| $Gamma(10, 1)$ | $Gamma(1, 1)$ | Shifted prior for $\alpha$. Informative prior for $\beta$. |
| $Gamma(49, 7)$ | $Gamma(4, 1)$  | Informative prior for $\alpha$. Shifted prior for $\beta$. |

: {tbl-colwidths="[25, 25, 50]"}

## Sensitivity Analysis for Gamma Scenario 1

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### $\alpha$

```{r}
readRDS(file.path(output_dir, "p1_prior.rds"))
```

### $\beta$

```{r}
readRDS(file.path(output_dir, "p2_prior.rds"))
```

::: 

## Coverage Assessment for Gamma Scenario 1

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### $\alpha$

```{r}
readRDS(file.path(output_dir, "p_ci_alpha.rds"))
```

### $\beta$

```{r}
readRDS(file.path(output_dir, "p_ci_beta.rds"))
```

::: 

## Coverage Assessment for Gamma Scenario 1‚Äôs $w$

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### $w_1$

```{r}
readRDS(file.path(output_dir, "p_ci_w1.rds"))
```

### $w_2$

```{r}
readRDS(file.path(output_dir, "p_ci_w2.rds"))
```

### $w_3$

```{r}
readRDS(file.path(output_dir, "p_ci_w3.rds"))
```

### $w_4$

```{r}
readRDS(file.path(output_dir, "p_ci_w4.rds"))
```

### $w_5$

```{r}
readRDS(file.path(output_dir, "p_ci_w5.rds"))
```

:::

## Coverage Assessment for Gamma Scenario 1‚Äôs $\rho$

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

### $\rho_1$

```{r}
readRDS(file.path(output_dir, "p_ci_rho1.rds"))
```

### $\rho_2$

```{r}
readRDS(file.path(output_dir, "p_ci_rho2.rds"))
```

### $\rho_3$

```{r}
readRDS(file.path(output_dir, "p_ci_rho3.rds"))
```

### $\rho_4$

```{r}
readRDS(file.path(output_dir, "p_ci_rho4.rds"))
```

### $\rho_5$

```{r}
readRDS(file.path(output_dir, "p_ci_rho5.rds"))
```

:::

## Trace and Density Plot for ZIGamma Scenario 1‚Äôs $w$

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
plots = readRDS(file.path(output_dir, "p_w_diag.rds"))
```

### $w_1$

```{r}
grid.arrange(plots[[1]], plots[[2]], ncol = 2)
```

### $w_2$

```{r}
grid.arrange(plots[[3]], plots[[4]], ncol = 2)
```

### $w_3$

```{r}
grid.arrange(plots[[5]], plots[[6]], ncol = 2)
```

### $w_4$

```{r}
grid.arrange(plots[[7]], plots[[8]], ncol = 2)
```

### $w_5$

```{r}
grid.arrange(plots[[9]], plots[[10]], ncol = 2)
```

:::

## Trace and Density Plot for ZIGamma Scenario 1‚Äôs $\rho$

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
plots = readRDS(file.path(output_dir, "p_rho_diag.rds"))
```

### $\rho_1$

```{r}
grid.arrange(plots[[1]], plots[[2]], ncol = 2)
```

### $\rho_2$

```{r}
grid.arrange(plots[[3]], plots[[4]], ncol = 2)
```

### $\rho_3$

```{r}
grid.arrange(plots[[5]], plots[[6]], ncol = 2)
```

### $\rho_4$

```{r}
grid.arrange(plots[[7]], plots[[8]], ncol = 2)
```

### $\rho_5$

```{r}
grid.arrange(plots[[9]], plots[[10]], ncol = 2)
```

:::

## Trace and Density Plot for ZIGamma Scenario 1's $\mu, \beta, P, \epsilon$

::: {.panel-tabset}

```{r}
output_dir <- "/Users/franceslin/GitHub/phd-dissertation-slides/data"
```

```{r}
p1 = readRDS(file.path(output_dir, "p1_diag.rds"))
p2 = readRDS(file.path(output_dir, "p2_diag.rds"))
p3 = readRDS(file.path(output_dir, "p3_diag.rds"))
p4 = readRDS(file.path(output_dir, "p4_diag.rds"))
p5 = readRDS(file.path(output_dir, "p5_diag.rds"))
p6 = readRDS(file.path(output_dir, "p6_diag.rds"))
p7 = readRDS(file.path(output_dir, "p7_diag.rds"))
p8 = readRDS(file.path(output_dir, "p8_diag.rds"))
```

### $\mu$

```{r}
grid.arrange(p1, p2, ncol = 2)
```

### $\beta$

```{r}
grid.arrange(p3, p4, ncol = 2)
```

### $P$

```{r}
grid.arrange(p5, p6, ncol = 2)
```

### $\epsilon$

```{r}
grid.arrange(p7, p8, ncol = 2)
```

:::

## RNN 

Let $x_t$, $h_t$, and $o_t$ denote the input data, the hidden state, and the output at time $t$, respectively. Then, an RNN unit can be expressed as: 
```{=latex} 
\begin{equation}
\begin{split}
\label{eq:rnn}
h_t &= f(W_{ih} h_{t-1} + W_{ix} x_t + b_i), \\
o_t &= g(W_{oh} \cdot h_t + b_o), 
\end{split}
\end{equation}
```
where  $W_{ix}$, $W_{ih}$ and $W_{oh}$ denote the weight matrices, and $b_i$ and $b_o$ the bias vectors. 

The subscripts $i$ and $o$ indicate their steps in RNN: $i$ refer to the input/hidden step, and $o$ to the output step. 

$f$ and $g$ denote the activation functions for the hidden layer and output layer, respectively. 

- $f$ is typically set to the logistic sigmoid function, denoted as $\sigma$, which outputs values in range $(0, 1)$ to act as a gate that controls how much information passes through. 

- $g$ is the hyperbolic tangent function, denoted as $tanh$, which outputs values in range $(-1, 1)$ to generate output in a stable, zero-centered range. 

## LSTM

Let $c_t$ and $h_t$ denote the cell and the hidden state vector. Let $f_t$, $i_t$, and $o_t$ represent the forget, the input, and the output gate vector at time $t$, respectively. Then, an LSTM unit can be expressed as: 
```{=latex} 
\begin{equation}
\begin{split}
\label{eq:lstm}
f_t &= \sigma(W_{fh} h_{t-1} + W_{fx} x_t + b_f), \\
i_t &= \sigma(W_{ih} h_{t-1} + W_{ix} x_t + b_i), \\
\tilde{c}_t &= \tanh(W_{\tilde{c} h} h_{t-1} + W_{\tilde{c} x} x_t + b_{\tilde{c}}), \\
c_t &= f_t \cdot c_{t-1} + i_t \cdot \tilde{c}_t, \\
o_t &= \sigma(W_{oh} h_{t-1} + W_{ox} x_t + b_o), \\
h_t &= o_t \cdot \tanh(c_t), 
\end{split}
\end{equation}
```
where $\boldsymbol{W}$ denotes the weight matrices, $\boldsymbol{b}$ the bias vectors, $\sigma$ the logistic sigmoid function, and $tanh$ the hyperbolic tangent function. 

## Training and Validation Loss Curves for LSTM

![](images/p_loss_real_bs81632_v2.png)

## Training and Validation Loss Curves for LSTM

![](images/p_loss_real_bs64128256_v2.png)